### 缓冲区

#### 定义：

临时存储区域

#### 分类：

- 完全缓冲(fully buffered I/O）
- 行缓冲(line-buffered I/o)

#### 意义：

1. 将若干个字符作为一个快传输比逐个发送这些字符耗费的时间少。

2. 如果输入有误，就可以使用键盘更正功能修正错误。

#### 注：

1. 一些交互性程序（如游戏命令），需要非缓冲输入。
2. 不存在调用非缓冲输入的标准ANSI方式。

### 终止键盘输入

#### 流(stream)：

​	一个理想化的数据流，实际输入或输出映射到这个数据流。这意味着具有不同属性的多种类型的输入由流表示，会具有更多统一的属性。于是打开文件的过程就成为将流与文件相关联，并通过流进行读写的过程。

#### EOF(End of File)

​	C语言让getchar()函数在达到文件结尾时返回一个特殊值，而不去管操作系统是如何检测文件结尾的。赋予该值的名称是EOF。因此，检测到文件尾时getchar() 的返回值是EOF。scanf () 函数在检测到文件结尾时也返回EOF。通常EOF在stdio.h文件中定义为`# define EOF (-1)`

```c
/*echo_eof.c --重复输入，直到文件的结尾*/
#include <stdio.h>
int main(void)
{
  int ch;
  while ((ch = getchar()) != EOF)
    putchar(ch);
  return 0;
}
```

**注意以下几点：**

- 不必定义EOF，因为stdio.h负责定义它。
- 不必担心EOF的实际值，因为stdio.h 中的#define语句使您能够使用EOF进行符号表示
- 变量ch从char类型改变为int类型
- ch是整数的事实不会对putchar()有任何影响
- 要对键盘输入使用此程序，您需要一种键入EOF字符的方式

#### 模拟的EOF和图形界面

```markdown
  模拟的EOF的概念是在使用文本界面的命令行环境中产生的。在这样的环境中，用户通过击键与程序互相作用，由操作形同产生EOF信号。一些实际情况中，没有很好地转换到图形界面中来，这些用户界面因为包含鼠标移动和按钮点击而更加复杂。遇到模拟的EOF时，程序的行为取决于编译器和项目类型。
```

### 重定向输入和输出的方法

​	在大多数C系统中，您都可以使用重定向。您可以通过操作系统对所有程序使用重定向，或者仅仅是在C编译器允许的情况下对C程序使用重定向。下面，令prog为可执行程序的名字，并令file1和file2为文件名。

**将输出重定向到一个文件: > prog > file1**

**将输入重定向为来自一个文件：prog < file2**

**组合重定向：**

- Prog < file2 > file1

- Prog > file1 < file2

  两种形式都使用file2作为输入，使用file1作为输出。

**空格：**

​	一些系统在重定向运算符左边需要一个空格，而在右边则不需要。其他系统既接受两边都有空格也接受两边都没有空格。