

# 深入理解计算机指针

## 第一章：认识指针

### 1.1 指针和内存

#### 1.1.1简介

 	程序在编译后，会以 三种形式使用内存。

- 静态/ 全局内存 

​		静态声明的变量分配在这里，全局变量也使用这部分内存。这些变量在程序开始运行时分配，直到程序终止才消失。所有函数都能		访问全局变量，静态变量的作用域则局限在定义它们的函数内部。

- 自动内存

  这些变量在函数内部声明，并且在函数被调用时才创建。 它们的作用域局限于函数内部，而且生命周期限制在函数的执行时间内。

- 动态内存

  内存分配在堆上，可以根据需要释放，而且直到释放才消失。指针引用分配的内 存，作用域局限于引用内存的指针，这是第2章重点。

|                      | 作用域                 | 生命周期             |
| :------------------- | :--------------------- | :------------------- |
| 全局内存             | 整个文件               | 应用程序的生命周期   |
| 静态内存             | 声明它的函数内部       | 应用程序的生命周期   |
| 自动内存（局部内存） | 声明它的函数内部       | 限制在函数执行时间内 |
| 动态内存             | 由引用该内存的指针决定 | 直到内存释放         |

​	指针变量包含内存中别的变量、对象或函数的地址。对象就是内存分配函数 (比如 malloc)分配的内存。指针通常根据所指的数据类型来声明。对象可以是任何C数据类型，如整数、字符、字符串或结构体。然而，指针本身并没有包含所引用数据的类型信息，指针只包含地址。

------

#### 1.1.2初始化

```c
//声明指针
int *pi1;
int* pi2;
int* pi3;
int*pi4;
const int *pci    /*pci是一个指向整数常量的指针变量*/
int *pi;
int num = 0;
pi = &num;
printf("Address of num: %d Value: %d\n",&num,num);
printf("Address of pi: %d Value: %d\n",&pi,pi);  /*打印地址*/
```

| 格式说明符 | 含义                                       |
| ---------- | ------------------------------------------ |
| %x         | 将值显示为十六进制数                       |
| %o         | 将值显示为八进制数                         |
| %p         | 将值显示为实现专用的格式，通常是十六进制数 |

**Tips：**

- 星号两边的空白字符无关紧要，空白符的使用是个人爱好；
- 星号将变量声明为指针；
- pi 的内容最终应该赋值为一个整数变量的地址；
- 如果变量没有被初始化，将包含的是垃圾数据；
- 指针的实现中没有内部信息表明自己指向的是什么类型的数据或者内容是否合法，不过，指针有类型，而且如果没有正确使用，编译器会频繁抱怨；
- 尽管不经过初始化就可以使用指针，但只有初始化后，指针才会正常工作；
- 很多程序员都发现倒过来读声明就没那么复杂了；
- 地址操作符&会返回操作数的地址，我们可以用这个操作符来初始化pi 指针；
- 把整数赋值给指针 一般都会导致警告或错误，不过，也可以把整数转换为指向整数的指针`pi = (int *)num;`
- 尽快初始化指针是一个好习惯;
- %p 和%x的不同之处在于:%p一般会把数字显示为十六进制大写。如果没有特别说 明，我们用%p 作为地址的说明符;
- 让打印地址变得更为复杂的是，在虛拟操作系统上显示的指针地址 一般不是真夹的 物理内存地址;
- 间接引用操作符 (*)返回指针变量指向的值，一般称为解引指针;
- 指针可以声明为指向函数,如`void (*foo) ();`,指针的名字是foo;

-------

#### 1.1.3Null的概念

​		NULL被赋值给指针就意味着指针不指向任何东西。null概念是指指针包含了一个特殊的值 ， 和别的指针不一样 ， 它没有指向任何 内存区域 。 两个null指针总是相等的。尽管不常见，但每一种指针类型 (如宇符指针和整数指针)都可以有对应的null指针类型。
​		Null概念是通过null指针常量来支持的一种抽象。这个常量可能是也可能不是常量0 ，C 程序员不需要关心实际的内部表示。
​		NULL宏是强制类型转换为void指针的整数常量0。在很多库中定义如下:

```c
#define NULL ((void *)0)
```

​		如果要把null值赋给pi，就像下面那样用：

``` c
pi = null;
```

​		null指针和未初始化的指针不同。未初始化的指针可能包含任何值，而包含NULL的指针则不会引用内存中的任何地址。

​		有趣的是，我们可以给指针赋0，但是不能赋任何别的整数值。看一下下面的赋值操作:

```c
pi = 0;
pi = NULL;
pi = 100; //语法错误
pi = num; //语法错误
```

**注：**

- 任何时候都不应该对null指针进行解引，因为它并不包含合法地址。执行这样的代码会导致程序终止；
- 指针被声明为全局或静态，就会在程序启动时被初始化为NULL。

----------

#### 1.1.4void指针

​		void指针是通用指针，用来存放任何数据类型的引用。下面的例子就是一个void 指针:
```c
void *pv;
```

它有两个有趣的性质:

- void指针具有与char指针相同的形式和内存对齐方式;

- void指针和别的指针永远不会相等，不过，两个赋值为NULL 的void指针是相等的。

​		任何指针都可以被赋给void指针，它可以被转换回原来的指针类型，这样的话指针的值和原指针的值是相等的。在下面的代码中，int指针被赋给void指针然后 ， 又被赋给int 指针：

```c
int num;
int *pi = &num;
printf("Value of pi: %p\n", pi); void* pv = pi;
pi = (int*) pv;
printf("Value of pi: %p\n", pi);
```

​		运行这段代码后，指针地址是 一样的:

```
Value of pi: 100
Value of pi: 100
```

**注：**

- void指针只用做数据指针，而不能用做函数指针；
- 用void指针的时候要小心，如果把任意指针转换为void指针，那就没有什么能阻止你再把它转换成不同的指针类型了；
- sizeof操作符可以用在void指针上，不过我们无法把这个操作符用在void上。

-------

### 1.2 指针的长度和类型

#### 1.2.1 机器内存模型

| 数据类型  | LP64 | ILP64 | LLP64 | ILP32 | LP32 |
| --------- | ---- | ----- | ----- | ----- | ---- |
| char      | 8    | 8     | 8     | 8     | 8    |
| short     | 16   | 16    | 16    | 16    | 16   |
| _int32    |      | 32    |       |       |      |
| int       | 32   | 64    | 32    | 32    | 16   |
| long      | 64   | 64    | 32    | 32    | 32   |
| long long |      |       |       |       |      |
| pointer   | 64   | 64    | 64    | 64    | 32   |

#### 1.2.2 指针相关的预定义类型 

​		使用指针时经常用到以下四种预定义类型 。 

- size_t

  ​		用于安全的表示长度

- ptrdiff_t

​				用于处理指针算数运算符

-  intptr_t和uintptr_t	

​				用于存储指针地址

##### size_t、sizeof、intptr_t和uintptr_t

***1. 理解size_t***

**定义：**

```c
#ifndef __SIZE_T
#define __SIZE_T
typedef unsigned int size_t; 
#endif
size_t sizet= -5;
printf("%d\n" ‚sizet); //把sizet当作有符号  打印-5
printf("%zu\n",sizet); //把sizet当作无符号整数 高位的1被当做2的乘幂 打印一个很大的数
/*正数则会正常显示*/
```

**注：**

- size_t 用做sizeof操作符的返回值类型，同时也是很多函数的参数类型，包括malloc和strlen；

- 在声明诸如字符数或者数组索引这样的长度变量时用size_t 是好的做法。它经常用于循环计数器、数组索引，有时候还用在指针算术运算上；

- 通常size_t可以用来存放指针，但是假定size_t和指针一样长不是个好主意。

- 打印size_t 类型的值时要小心，这是无符号值，如果选错格式说明符，可能会得到不可靠的结果。推荐的格式说明符是%zu，不过

  某些情况下不能用这个说明符，作为替代，可以考虑%u 或%lu。

***2. 对指针使用sizeof操作符***

​	当需要用指针长度时，一定要用sizeof操作符

```c
printf("Size of *char: %d\n", sizeof (char*));
```

>输出：`Size of *char: 4`

***3. 使用intptr _t和uintptr_t***

**定义：**

​		intptr_ t和uintptr_t类型用来存放指针地址。 它们提供了一种可移植且安全的方法声明指针，而且和系统中使用的指针长度相同，对于把指针转化成整数形式来说很有用。

```c
int num;
intptr_t *pi = &num;
```

​		如果像下面那样试图把整数地址赋给uintptr_t 类型的指针，我们会得到一个语法错误:

```c
uintptr_t *pu = &num;
```



​		错误看起来是这样的:

```
error: invalid conversion from 'int*' to
'uintptr t* (aka unsigned i n t * ' (-fpermissive)
```

​		不过，用强制类型转换来赋值是可以的:

```c
intptr t *pi = &num;
uintptr_t *pu = (uintptr_t*)&num;
```

​		如果不转换类型，不能将uintptr_t 用于共他类型:

```c
char c;
uintptr_t *pc = (uintptr_t*)&c;
```

		- 避免把指针转换成整数。如果指针是64 位，整数只有4字节时就会丢失信息。
		- 当可移植性和安全性变得重要时，就应该使用这些类型。



​		













